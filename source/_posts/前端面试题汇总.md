---
title: 前端面试题汇总
date: 2022-07-20 16:39:31
tags: 前端面试题汇总
---

#### 1、for in 和foreach谁执行效率快？

forEach 每次都要创建一个函数来调用，而for不会创建函数
函数需要独立的作用域，会有额外的开销

#### 2、vuex的优缺点

优点：

> 能够在vuex中,集中管理共享的数据,易于开发和后期维护；
>
> Vuex 的状态存储是响应式的，当 Vue 组件从 store中读取状态的时候，若 store 中的状态发生变化，能够触发响应式的渲染页面更新 (localStorage就不会)，那么相应的组件也会相应地得到高效更新。
>
> js 原生的数据对象写法, 比起 localStorage 不需要做转换, 使用方便
>
> 限定了一种可预测的方式改变数据, 避免大项目中, 数据不小心的污染

缺点

> 刷新浏览器，vuex中的state会重新变为初始状态 ；
>
> 解决方案-插件 vuex-persistedstate

#### 3、如何减少http请求的次数

1. 能做雪碧图就做雪碧图
2. base64编码（把一张小于多少大小的图片变成一种64位编码的形式）
因为编码就不用请求，就直接解析成一张图片
坏处是增加了数据量，增加了请求时间
只建议用内存比较小的图标采取这种方式
3. 合并脚本与样式表代码
HTML/JS/CSS
4. 缩小CSS和JavaScrit文件
你用你的域名在第三方服务器上进行解析，从而生成CDN加速域名（七牛云）
5. 尽量使用浏览器的缓存机制
6. 实施延迟加载技术
7. 减少外部脚本的数量
8. 使用内容分发网络（CDN）
CDN是位于世界各地的服务器网络。CDN在您的网站上缓存静态资源，然后用户访问您的网页时，将其提供给缓存的内容。缓存的内容是从服务器交付的，最接近用户的物理位置。
是否要使用CDN取决于几件事，最重要的是您的流量是本地流量还是国际流量。如果您的大多数网站访问者是本地访问者，则不需要内容交付网络（CDN加速）

#### 4、px、em、rem的区别

一、px是固定的像素，一旦设置了就无法因为适应页面大小而改变。

二、em和rem相对于px更具有灵活性，他们是相对长度单位，意思是长度不是定死了的，更适用于响应式布局。

三、em是相对于其父元素来设置字体大小的，一般都是以<body>的“font-size”为基准。这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而Rem是相对于根元素<html>，这样就意味着，我们只需要在根元素确定一个参考值。

总之：对于em和rem的区别一句话概括：em相对于父元素，rem相对于根元素。

#### 5、css优先级算法

选择器的优先级顺序是由各个选择器的权重决定的。具体如下表：

#### 6、写出代码打印结果

```js
var name = 'World';
(function(){
  if (typeof name === 'undefined') {
    var name = 'AJ'
    console.log('Hi' + name);
  } else {
    console.log('Hello' + name);
  }
})()
// HiAJ
```

```js
function changeObhProperty(o) {
  o.siteUrl = 'https://www.ke.com';
  o = new Object()
  o.siteUrl = 'https://www.lianjia.com';
}
let webSide = new Object();
changeObhProperty(webSide);
console.log(webSide.siteUrl);
// https://www.ke.com
```

#### 6、浏览器的重绘与回流

浏览器的渲染原理：
1.解析HTML，生成DOM树，解析CSS，生成CSSOM树
2.将DOM树和CSSOM树结合，生成渲染树(Render Tree)

**回流：**

回流是布局或者几何属性需要改变就称为回流。回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面（或是整个页面）的布局更新。一个元素的回流可能会导致了其所有子元素以及DOM中紧随其后的节点、祖先节点元素的随后的回流。

**重绘：**

重绘是由于节点的几何属性发生改变或者由于样式发生改变但不会影响布局。例如outline, visibility, color、background-color等，重绘的代价是高昂的，因为浏览器必须验证DOM树上其他节点元素的可见性。

**什么时候发生回流**

1. 添加或删除可见的DOM元素
2. 元素的位置发生变化
3. 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）
4. 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。
5. 页面一开始渲染的时候（这肯定避免不了）
6. 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）

回流一定会触发重绘，而重绘不一定会回流

##### 1、CSS优化法

1. 使用 transform 替代 top
2. 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局
3. 避免使用table布局，可能很小的一个小改动会造成整个 table 的重新布局。
4. 尽可能在DOM树的最末端改变class，回流是不可避免的，但可以减少其影响。尽可能在DOM树的最末端改变class，可以限制了回流的范围，使其影响尽可能少的节点。
5. 避免设置多层内联样式，CSS 选择符从右往左匹配查找，避免节点层级过多。
6. 将动画效果应用到position属性为absolute或fixed的元素上，避免影响其他元素的布局，这样只是一个重绘，而不是回流，同时，控制动画速度可以选择 requestAnimationFrame。
7. 避免使用CSS表达式，可能会引发回流。
8. 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点，例如will-change、video、iframe等标签，浏览器会自动将该节点变为图层。
9. CSS3 硬件加速（GPU加速），使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。但是对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。

##### 2、JavaScript优化法

1. 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。
2. 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。 
3. 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。

#### 7、节流和防抖

1. 节流

节流是在一段时间内只运行一次，若在一段时间内重复触发，只有一次生效。

```js
function throttle(fun, delay) {
  let flag = true;
  return function () {
    if (!flag) {
      return;
    }
    flag=false;
    setTimeout(() => {
      fun.apply(this, arguments);
      flag = true;
    }, delay)
  };
}
```

2. 防抖

防抖是在一段时间后再执行操作，若在一段时间内被重复触发，则重新计时。

```js
function antiShake(fun, delay) {
  let timeout = null;
  return function (e) {
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      fun.apply(this, arguments);
    }, delay)
  };
}
```

#### 8、什么是缓存，及其作用

缓存其实就是一个临时的存储器。缓存有 ：cookie、session、application、cache、redis

缓存主要是为了提高数据的读取速度。因为服务器和应用客户端之间存在着流量的瓶颈，所以读取大容量数据时，使用缓存来直接为客户端服务，可以减少客户端与服务器端的数据交互，从而大大提高程序的性能。
以前实现数据的缓存有很多种方法，有客户端的Cookie，有服务器端的Session和Application。其中Cookie是保存在客户端的一组数据，主要用来保存用户名等个人信息。Session则保存对话信息。Application则是保存在整个应用程序范围内的信息，相当于全局变量。通常使用最频繁的是Session，缓存也是有限的，会自动清除之前的旧数据。其中redis的读取速度最快，并且是在内存中进行读取，当内存不够时可以扩大内存，还有就是 .net提供的Cache缓存.

#### 9、封装一个异步加载图片的方法

```js
loadImageAsync("./loadImg.jpg").then(image => document.body.appendChild(image))

// 异步加载图片函数封装
function loadImageAsync(url) {
  return new Promise(function(resolve, reject) {
    const image = new Image();
    image.src = url;
    image.onload = function() {
      resolve(image);
    };
    image.onerror = function() {
      reject(new Error('Could not load image at ' + url));
    };
  });
}
```

#### 10、webpack中loader和plugin的区别

**loader**从字面的意思理解，是加载的意思。由于webpack 本身只能打包js文件，所以，针对css，图片等格式的文件没法打包，就需要引入第三方的模块进行打包。loader虽然是扩展了 webpack ，但是它只专注于转化文件（transform）这一个领域，完成压缩，打包，语言翻译。loader是运行在NodeJS中。仅仅只是为了打包。
如：<font color=red>css-loader和style-loader模块是为了打包css的<font>
<font color=red>babel-loader和babel-core模块时为了把ES6的代码转成ES5<font>
<font color=red>url-loader和file-loader是把图片进行打包的。<font>
**plugin**也是为了扩展webpack的功能，但是 plugin 是作用于webpack本身上的。而且plugin不仅只局限在打包，资源的加载上，它的功能要更加丰富。从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack提供了很多开箱即用的插件.

#### 11、webpack优化配置

##### 1、开发环境性能优化

- 优化打包构建速度
1. HMR
一个模块发生变化，只会重新打包这一个模块（而不是打包所有模块） 极大提升构建速度
- 优化代码调试
1. source-map
 一种 提供源代码到构建后代码映射 技术 （如果构建后代码出错了，通过映射可以追踪源代码错误）

##### 2、生产环境性能优化

- 优化打包构建速度
1. oneOf
oneOf提高打包构建速度；
只会匹配一个loader；
类似于数组列表，以前每一个文件需要遍历全部找到处理该文件类型对应loader，而使用oneOf 只需要使用匹配到的loader即可。
2. babel缓存
3. 多进程打包
4. externals
5. dll
- 优化代码运行的性能
1. 缓存(hash-chunkhash-contenthash)
2. tree shaking(摇树)
3. code split（代码拆分）
4. 懒加载/预加载
5. pwa（渐进式网络开发应用程序(离线可访问)）

#### 12、地址栏输入url 发生了什么

- 首先会进行 url 解析，根据 dns 系统进行 ip 查找
- 根据 ip 就可以找到服务器，然后浏览器和服务器会进行 TCP 三次握手建立连接，如果此时是 https 的话，还会建立 TLS 连接以及协商加密算法。
- 连接建立之后浏览器开始发送请求获取文件，此时这里还会出现一种情况就是缓存，建立连接后是走缓存还是直接重新获取，需要看后台设置。
- 首先获取 html 文件，构建 DOM 树，这个过程是边下载边解析，并不是等 html 文件全部下载完了，再去解析 html，这样比较浪费时间，而是下载一点解析一点
- 好了解析到 html 头部时候，又会出现一种问题，css,js 放到哪里了？不同的位置会造成渲染的不同，此时就会出现另一个需要关注的问题"css,js 位置应该放哪里?为什么"，我们先按照正确的位置来说明(css 放头部,js 放尾部)
- 解析到了 html 头部发现有 css 文件，此时下载 css 文件，css 文件也是一边下载一边解析的，构建的是 CSSOM 树，当 DOM 树和 CSSOM 树全部构建完之后，浏览器会把 DOM 树和 CSSOM 树构建成渲染树。
- 样式计算, 上面最后一句"DOM 树和 CSSOM 树会一起构建成渲染树"说的有点笼统，其实还有更细一点的操作，但是一般回答到上面应该就可以了，我们现在接上面说一下构造渲染树的时候还做了哪些事情。第一个就是样式计算，DOM树 和 CSSOM树有了之后，浏览器开始样式计算，主要是为 DOM 树上的节点找到对应的样式
- 构建布局树，样式计算完之后就开始构建布局树。主要是为 DOM 树上的节点找到页面上对应位置以及一些"display:none"元素的隐藏。
- 构建分层树，布局树完成后浏览器还需要建立分层树，主要是为了满足滚动条，z-index，position 这些复杂的分层操作
- 将分层树图块化，利用光栅找到视图窗口下的对应的位图。主要是因为一个页面可能有几屏那么长，一下渲染出来比较浪费，所以浏览器会找到视图窗口对应的图块，将这部分的图块进行渲染
- 最终渲染进程将整个页面渲染出来，在渲染的过程中会还出现重排和重绘。
- 以上过程大概讲解了一下从 url 到页面渲染的整个过程。

#### 13、js css 顺序对前端优化影响

渲染树的构成必须要 DOM 树和 CSSOM 树的，所以尽快的构建 CSSOM 树是一个重要的优化手段，如果 css 文件放在尾部，那么整个过程就是一个串行的过程先解析了 dom，再去解析 css。所以 css 我们一般都是放在头部，这样 DOM 树和 CSSOM 树的构建是同步进行的。

再来看 js，因为 js 的运行会阻止 DOM 树的渲染的，所以一旦我们的 js 放在了头部，而且也没有异步加载这些操作的话，js 一旦一直在运行，DOM 树就一直构建不出来，那么页面就会一直出现白屏界面，所以一般我们会把 js 文件放在尾部。当然放到尾部也不是就没有问题了，只是问题相对较小，放到尾部的 js 文件如果过大，运行时间长，代码加载时，就会有大量耗时的操作造成页面不可点击，这就是另一个问题，但这肯定比白屏要好，白屏是什么页面都没有，这种是页面有了只是操作不流畅。

js 脚本放在尾部还有一个原因，有时候 js 代码会有操作 dom 节点的情况，如果放在头部执行，DOM树还没有构建，拿不到 DOM 节点但是你又去使用就会出现报错情况，错误没处理好的话页面会直接崩掉。