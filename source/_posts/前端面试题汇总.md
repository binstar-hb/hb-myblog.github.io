---
title: 前端面试题汇总
date: 2022-07-20 16:39:31
tags: 前端面试题汇总
---

#### 1、vuex的优缺点

优点：

> 能够在vuex中,集中管理共享的数据,易于开发和后期维护；
>
> Vuex 的状态存储是响应式的，当 Vue 组件从 store中读取状态的时候，若 store 中的状态发生变化，能够触发响应式的渲染页面更新 (localStorage就不会)，那么相应的组件也会相应地得到高效更新。
>
> js 原生的数据对象写法, 比起 localStorage 不需要做转换, 使用方便
>
> 限定了一种可预测的方式改变数据, 避免大项目中, 数据不小心的污染

缺点

> 刷新浏览器，vuex中的state会重新变为初始状态 ；
>
> 解决方案-插件 vuex-persistedstate

#### 2、如何减少http请求的次数

1. 能做雪碧图就做雪碧图
2. base64编码（把一张小于多少大小的图片变成一种64位编码的形式）
因为编码就不用请求，就直接解析成一张图片
坏处是增加了数据量，增加了请求时间
只建议用内存比较小的图标采取这种方式
3. 合并脚本与样式表代码
HTML/JS/CSS
4. 缩小CSS和JavaScrit文件
你用你的域名在第三方服务器上进行解析，从而生成CDN加速域名（例：七牛云）
5. 尽量使用浏览器的缓存机制
6. 实施延迟加载技术
7. 减少外部脚本的数量
8. 使用内容分发网络（CDN）
CDN是位于世界各地的服务器网络。CDN在您的网站上缓存静态资源，然后用户访问您的网页时，将其提供给缓存的内容。缓存的内容是从服务器交付的，最接近用户的物理位置。
是否要使用CDN取决于几件事，最重要的是您的流量是本地流量还是国际流量。如果您的大多数网站访问者是本地访问者，则不需要内容交付网络（CDN加速）

#### 3、px、em、rem的区别

一、px是固定的像素，一旦设置了就无法因为适应页面大小而改变。

二、em和rem相对于px更具有灵活性，他们是相对长度单位，意思是长度不是定死了的，更适用于响应式布局。

三、em是相对于其父元素来设置字体大小的，一般都是以<body>的“font-size”为基准。这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而Rem是相对于根元素<html>，这样就意味着，我们只需要在根元素确定一个参考值。

总之：对于em和rem的区别一句话概括：em相对于父元素，rem相对于根元素。

#### 4、css优先级算法

选择器的优先级顺序是由各个选择器的权重决定的。具体如下表：

| 选择器                                | 权重值                                                       |
| :------------------------------------ | :----------------------------------------------------------- |
| !important                            | [infinity](https://so.csdn.net/so/search?q=infinity&spm=1001.2101.3001.7020)(无穷大) |
| 行内样式 style" "                     | 1000                                                         |
| id选择器                              | 100                                                          |
| class类选择器、属性选择器、伪类选择器 | 10                                                           |
| 标签（元素）选择器                    | 1                                                            |
| 通配符（*）选择器                     | 0                                                            |

- 优先级就近原则，同权重情况下样式定义最近者为准
- 载入样式以最后载入的定位为准
- 优先级为: `!important > 行内style > id > class > tag`; 

#### 5、写出代码打印结果

```js
var name = 'World';
(function(){
  if (typeof name === 'undefined') {
    var name = 'AJ'
    console.log('Hi' + name);
  } else {
    console.log('Hello' + name);
  }
})()
// HiAJ
```

```js
function changeObhProperty(o) {
  o.siteUrl = 'https://www.ke.com';
  o = new Object()
  o.siteUrl = 'https://www.lianjia.com';
}
let webSide = new Object();
changeObhProperty(webSide);
console.log(webSide.siteUrl);
// https://www.ke.com
```

#### 6、浏览器的重绘与回流

浏览器的渲染原理：
1.解析HTML，生成DOM树，解析CSS，生成CSSOM树
2.将DOM树和CSSOM树结合，生成渲染树(Render Tree)

**回流：**

回流是布局或者几何属性需要改变就称为回流。回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面（或是整个页面）的布局更新。一个元素的回流可能会导致了其所有子元素以及DOM中紧随其后的节点、祖先节点元素的随后的回流。

**重绘：**

重绘是由于节点的几何属性发生改变或者由于样式发生改变但不会影响布局。例如outline, visibility, color、background-color等，重绘的代价是高昂的，因为浏览器必须验证DOM树上其他节点元素的可见性。

**什么时候发生回流**

1. 添加或删除可见的DOM元素
2. 元素的位置发生变化
3. 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）
4. 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。
5. 页面一开始渲染的时候（这肯定避免不了）
6. 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）

回流一定会触发重绘，而重绘不一定会回流

##### 1、CSS优化法

1. 使用 transform 替代 top
2. 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局
3. 避免使用table布局，可能很小的一个小改动会造成整个 table 的重新布局。
4. 尽可能在DOM树的最末端改变class，回流是不可避免的，但可以减少其影响。尽可能在DOM树的最末端改变class，可以限制了回流的范围，使其影响尽可能少的节点。
5. 避免设置多层内联样式，CSS 选择符从右往左匹配查找，避免节点层级过多。
6. 将动画效果应用到position属性为absolute或fixed的元素上，避免影响其他元素的布局，这样只是一个重绘，而不是回流，同时，控制动画速度可以选择 requestAnimationFrame。
7. 避免使用CSS表达式，可能会引发回流。
8. 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点，例如will-change、video、iframe等标签，浏览器会自动将该节点变为图层。
9. CSS3 硬件加速（GPU加速），使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。但是对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。

##### 2、JavaScript优化法

1. 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。
2. 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。 
3. 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。

#### 7、节流和防抖

1. 节流

节流是在一段时间内只运行一次，若在一段时间内重复触发，只有一次生效。(场景示例：点击按钮登录)

```js
function throttle(fun, delay) {
  let flag = true;
  return function () {
    if (!flag) {
      return;
    }
    flag=false;
    setTimeout(() => {
      fun.apply(this, arguments);
      flag = true;
    }, delay)
  };
}
```

2. 防抖

防抖是在一段时间后再执行操作，若在一段时间内被重复触发，则重新计时。(场景示例：搜索框自动执行模糊匹配)

```js
function antiShake(fun, delay) {
  let timeout = null;
  return function (e) {
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      fun.apply(this, arguments);
    }, delay)
  };
}
```

#### 8、什么是缓存，及其作用

缓存其实就是一个临时的存储器。缓存有 ：cookie、session、application、cache、redis

缓存主要是为了提高数据的读取速度。因为服务器和应用客户端之间存在着流量的瓶颈，所以读取大容量数据时，使用缓存来直接为客户端服务，可以减少客户端与服务器端的数据交互，从而大大提高程序的性能。
以前实现数据的缓存有很多种方法，有客户端的Cookie，有服务器端的Session和Application。其中Cookie是保存在客户端的一组数据，主要用来保存用户名等个人信息。Session则保存对话信息。Application则是保存在整个应用程序范围内的信息，相当于全局变量。通常使用最频繁的是Session，缓存也是有限的，会自动清除之前的旧数据。其中redis的读取速度最快，并且是在内存中进行读取，当内存不够时可以扩大内存，还有就是 .net提供的Cache缓存.

#### 9、封装一个异步加载图片的方法

```js
loadImageAsync("./loadImg.jpg").then(image => document.body.appendChild(image))

// 异步加载图片函数封装
function loadImageAsync(url) {
  return new Promise(function(resolve, reject) {
    const image = new Image();
    image.src = url;
    image.onload = function() {
      resolve(image);
    };
    image.onerror = function() {
      reject(new Error('Could not load image at ' + url));
    };
  });
}
```

#### 10、webpack中loader和plugin的区别

**loader**从字面的意思理解，是加载的意思。由于webpack 本身只能打包js文件，所以，针对css，图片等格式的文件没法打包，就需要引入第三方的模块进行打包。loader虽然是扩展了 webpack ，但是它只专注于转化文件（transform）这一个领域，完成压缩，打包，语言翻译。loader是运行在NodeJS中。仅仅只是为了打包。
如：<font color=red>css-loader和style-loader模块是为了打包css的</font>
<font color=red>babel-loader和babel-core模块时为了把ES6的代码转成ES5</font>
<font color=red>url-loader和file-loader是把图片进行打包的。</font>
**plugin**也是为了扩展webpack的功能，但是 plugin 是作用于webpack本身上的。而且plugin不仅只局限在打包，资源的加载上，它的功能要更加丰富。从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack提供了很多开箱即用的插件.

#### 11、webpack优化配置

##### 1、开发环境性能优化

- 优化打包构建速度
1. HMR

  ```
  一个模块发生变化，只会重新打包这一个模块（而不是打包所有模块） 极大提升构建速度
  ```
- 优化代码调试
1. source-map

 ```
 一种 提供源代码到构建后代码映射 技术 （如果构建后代码出错了，通过映射可以追踪源代码错误）
 ```

##### 2、生产环境性能优化

- 优化打包构建速度
1. **<font color=red>oneOf</font>**
    oneOf提高打包构建速度；
    只会匹配一个loader；
    类似于数组列表，以前每一个文件需要遍历全部找到处理该文件类型对应loader，而使用oneOf 只需要使用匹配到的loader即可。

2. **<font color=red>babel缓存</font>**
    babel对我们写的js代码做编译处理时，假设有100个js模块，一个模块变，只变这一个模块，其他模块不变。
    开启babel缓存，之后的 webpack 构建，将会尝试读取缓存，来避免在每次执行时，可能产生的、高性能消耗的 Babel 重新编译过程。

3. **<font color=red>多进程打包</font>**
    Thread-loader：Webpack 官方出品，以多进程方式运行资源加载逻辑

4. **<font color=red>externals</font>**
    不想把第三方库打包到bundle中，这就有了externals。

5. **<font color=red>dll</font>**
    dll的作用是将项目中一些不常改变的依赖单独打包

- 优化代码运行的性能
1. **<font color=red>缓存(hash-chunkhash-contenthash)</font>**
    浏览器为了优化体验，会有缓存机制。如果浏览器判断当前资源没有更新，就不会去服务端下载，而是直接使用本地资源。在webpack的构建中，我们通常使用给文件添加后缀值来改名以及提取公共代码到不会改变的lib包中来解决新资源缓存问题。
    hash:模块标识符，我们知道对于webpack来说，它是一个打包编译的过程，也就是一个 compilation的过程，这个标识符，标识的就是这个打包的过程。这样就很好解释了模块标识符的概念就是在相同编译打包过程中的模块所共有的标识符，也就是说同一过程产出的产物的hash值都是一样的，也就解释了上面的过程。
    但是这样会有很大的问题，因为我们不想改变css模块而去影响到js打包出来的名称，这样不利于我们去做缓存。
    chunkhash:chunk指代的是模块，顾名思义，chunkhash就是模块的hash，也就是根据模块内容计算的hash值。那这边我们css模块的修改和js模块就没有关系。
    contenthash：从名称上我们可以知道，它是根据文件内容来定义hash所得，所以我们就可以使用插件extract-text-webpack-plugin定义的contenthash来打包。

2. **<font color=red>tree shaking(摇树)</font>**
    用于描述移除 JavaScript 上下文中的未引用代码
    Tree Shaking 是一个术语，在计算机中表示消除死代码，依赖于ES Module的静态语法分析（不执行任何的代码，可以明确知道模块的依赖关系）
    在webpack实现Trss shaking有两种不同的方案：
   - **usedExports**：通过标记某些函数是否被使用，之后通过Terser来进行优化的
   - **sideEffects**：跳过整个模块/文件，直接查看该文件是否有副作用

3. **<font color=red>code split（代码拆分 - splitChunksPlugin）</font>**
    将一个文件打包生成多个文件，这样做可以将一个大的文件分割成多个小的文件同时并行加载。同时分割成多个文件还可以实现按需加载的功能

  将代码分离到不同的bundle中，之后我们可以按需加载，或者并行加载这些文件
  默认情况下，所有的JavaScript代码（业务代码、第三方依赖、暂时没有用到的模块）在首页全部都加载，就会影响首页的加载速度
  代码分离可以分出出更小的bundle，以及控制资源加载优先级，提供代码的加载性能
  这里通过splitChunksPlugin来实现，该插件webpack已经默认安装和集成，只需要配置即可
  默认配置中，chunks仅仅针对于异步（async）请求，我们可以设置为initial或者all

4. **<font color=red>懒加载/预加载</font>**
   ```js
   //懒加载或者按需加载，会在文件需要使用时才加载，是一种很好的优化网页或应用的方式。
   document.getElementById('btn').onclick = function() {
     // 懒加载~：当文件需要使用时才加载~
     import(/* webpackChunkName: 'test'*/'./test').then(({ mul }) => {
       console.log(mul(4, 5));
     });
   };
   
   //在声明 import 时，使用webapck的内置指令/* webpackPrefetch: true */就可以对指定资源进行预加载
   document.getElementById('btn').onclick = function() {
     // 预加载 prefetch：会在使用之前，提前加载js文件 
     // 正常加载可以认为是并行加载（同一时间加载多个文件）  
     // 预加载 prefetch：等其他资源加载完毕，浏览器空闲了，再偷偷加载资源
     import(/* webpackChunkName: 'test', webpackPrefetch: true */'./test').then(({ mul }) => {
       console.log(mul(4, 5));
     });
   };
   ```

5. **<font color=red>pwa（渐进式网络开发应用程序(离线可访问)</font>**
    它让我们的应用程序可以像 APP 一样，离线也能访问，性能也更好。但是由于兼容性问题，现在还没有大面积推广开来（但是大厂有使用，比如说淘宝）。要在项目中真正使用PWA，我们需要借助 workbox 这个库，而在 webpack 中，我们还需要引入 workbox-webpack-plugin 这个插件。

6. **<font color=red>JS代码压缩 (terser-webpack-plugin)</font>**
    terser是一个JavaScript的解释、绞肉机、压缩机的工具集，可以帮助我们压缩、丑化我们的代码，让bundle更小

7. **<font color=red>CSS代码压缩 (css-minimizer-webpack-plugin)</font>**
    CSS压缩通常是去除无用的空格等，因为很难去修改选择器、属性的名称、值等

8. **<font color=red>Html文件代码压缩 (HtmlWebpackPlugin)</font>**
    使用HtmlWebpackPlugin插件来生成HTML的模板时候，通过配置属性minify进行html优化

9. **<font color=red>文件大小压缩 (compression-webpack-plugin)</font>**
    对文件的大小进行压缩，减少http传输过程中宽带的损耗

10. **<font color=red>图片压缩 (image-webpack-loader)</font>**
    一般来说在打包之后，一些图片文件的大小是远远要比 js 或者 css 文件要来的大，所以图片压缩较为重要

11. **<font color=red>内联chunk (InlineChunkHtmlPlugin)</font>**
    可以通过InlineChunkHtmlPlugin插件将一些chunk的模块内联到html，如runtime的代码（对模块进行解析、加载、模块信息相关的代码），代码量并不大，但是必须加载的
#### 12、地址栏输入url 发生了什么

1.在浏览器中输入一个url
2.根据域名解析出ip地址（dns的过程）
（1）先检查浏览器缓存，如果有，返回，没有，下一步
（2）检查系统缓存，hosts文件
（3）检查网络中路由器的dns缓存
（4）递归查询，不优先查找浏览器所在的本地域名服务器，先查找其他域名服务器，看有没有，如果没有，再查找本地域名服务器，本地域名服务器用迭代查询来查找
（5）迭代查询，不断向上访问，查找
3.根据找到的ip地址建立tcp连接
三次握手
4.发送http请求
5.如果发生重定向，状态码是3开头，那么返回第一步，继续匹配重定向的服务器
6.向重定向的服务器发送http请求
7.服务器处理请求，并且服务器发送html响应
8.浏览器收到http响应，tcp断开连接
9.如果得到的资源(静态)可以缓存，进行缓存
10.读取页面内容，浏览器渲染，解析html源码
11.生成Dom树、解析css样式、js交互
12.显示页面(html解析过程中会逐步显示页面)
- 首先获取 html 文件，构建 DOM 树，这个过程是边下载边解析，并不是等 html 文件全部下载完了，再去解析 html，这样比较浪费时间，而是下载一点解析一点
- 好了解析到 html 头部时候，又会出现一种问题，css,js 放到哪里了？不同的位置会造成渲染的不同，此时就会出现另一个需要关注的问题"css,js 位置应该放哪里?为什么"，我们先按照正确的位置来说明(css 放头部,js 放尾部)
- 解析到了 html 头部发现有 css 文件，此时下载 css 文件，css 文件也是一边下载一边解析的，构建的是 CSSOM 树，当 DOM 树和 CSSOM 树全部构建完之后，浏览器会把 DOM 树和 CSSOM 树构建成渲染树。
- 样式计算, 上面最后一句"DOM 树和 CSSOM 树会一起构建成渲染树"说的有点笼统，其实还有更细一点的操作，但是一般回答到上面应该就可以了，我们现在接上面说一下构造渲染树的时候还做了哪些事情。第一个就是样式计算，DOM树 和 CSSOM树有了之后，浏览器开始样式计算，主要是为 DOM 树上的节点找到对应的样式
- 构建布局树，样式计算完之后就开始构建布局树。主要是为 DOM 树上的节点找到页面上对应位置以及一些"display:none"元素的隐藏。
- 构建分层树，布局树完成后浏览器还需要建立分层树，主要是为了满足滚动条，z-index，position 这些复杂的分层操作
- 将分层树图块化，利用光栅找到视图窗口下的对应的位图。主要是因为一个页面可能有几屏那么长，一下渲染出来比较浪费，所以浏览器会找到视图窗口对应的图块，将这部分的图块进行渲染
- 最终渲染进程将整个页面渲染出来，在渲染的过程中会还出现重排和重绘。
- 以上过程大概讲解了一下从 url 到页面渲染的整个过程。

#### 13、js css 顺序对前端优化影响

渲染树的构成必须要 DOM 树和 CSSOM 树的，所以尽快的构建 CSSOM 树是一个重要的优化手段，如果 css 文件放在尾部，那么整个过程就是一个串行的过程先解析了 dom，再去解析 css。所以 css 我们一般都是放在头部，这样 DOM 树和 CSSOM 树的构建是同步进行的。

再来看 js，因为 js 的运行会阻止 DOM 树的渲染的，所以一旦我们的 js 放在了头部，而且也没有异步加载这些操作的话，js 一旦一直在运行，DOM 树就一直构建不出来，那么页面就会一直出现白屏界面，所以一般我们会把 js 文件放在尾部。当然放到尾部也不是就没有问题了，只是问题相对较小，放到尾部的 js 文件如果过大，运行时间长，代码加载时，就会有大量耗时的操作造成页面不可点击，这就是另一个问题，但这肯定比白屏要好，白屏是什么页面都没有，这种是页面有了只是操作不流畅。

js 脚本放在尾部还有一个原因，有时候 js 代码会有操作 dom 节点的情况，如果放在头部执行，DOM树还没有构建，拿不到 DOM 节点但是你又去使用就会出现报错情况，错误没处理好的话页面会直接崩掉。

#### 14、js事件循环机制

javascript是单线程执行的程序，也就是它只有一条主线，所有的程序都是逐行“排队”执行，在这种情况下可能存在一些问题，比如说setTimeout、ajax等待执行的时间较长，就会阻塞后续代码的执行，使得整个程序执行的耗时非常久，那么为了应对这样一个问题，javascript代码在执行的时候，是有几个“通道”的。

首先是调用栈，执行耗时较短的操作，耗时较长的操作先放置到任务队列中，任务队列又分为宏任务（macro-task）和微任务（micro-task），微任务中队列中放置的是 promise.then、async、await 这样操作，宏任务队列中放置的是 setTimeout、ajax、onClick事件，等调用栈的任务执行完成再轮询微任务队列，微任务队列中任务执行完成之后再执行宏任务。

这里提到了栈和队列，简单说一下这两种数据结构，栈是一种后进先出的结构，只能从尾部进入，从尾部删除，拿生活中的场景来打比方，就好像自助餐的餐盘，最先放的盘子在最底下，最后放的盘子在最上面，需要把最上面的盘子一个个拿走，才能拿到最下面的盘子。

而队列，是一种先进先出的结构，从尾部进入，从头部删除，就像我们去排队买东西，先去的同学可以先买到。

![image.png](https://pic4.58cdn.com.cn/nowater/webim/big/n_v2c5b0e68379fb478faced4898d04cf184.png)

再回到事件循环机制（event loop），不阻塞主进程的程序放入调用栈中，压入栈底，执行完了就会弹出，如果是函数，那么执行完函数里所有的内容才会弹出，而阻塞主进程的程序放入任务队列中，他们需要“排队”依次执行。

判断执行顺序可以记住以下几个重点

1. promise中的回调函数立刻执行，then中的回调函数会推入微任务队列中，等待调用栈所有任务执行完才执行
2. async函数里的内容是放入调用栈执行的，await的下一行内容是放入微任务执行的
3. 调用栈执行完成后，会不断的轮询微任务队列，即使先将宏任务推入队列，也会先执行微任务

#### 15、new操作符工作原理

1. 创建空对象，作为将要返回对象的实例
2. 将空对象的`__proto__`指向构造函数的prototype属性
3. 将空对象赋值给函数中的this
4. 开始执行构造函数,返回一个object

#### 16、vue中Diff算法、key的作用原理

1. Diff算法步骤：
 - 用js对象结构（虚拟DOM）表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中
 - 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异
 - 把所记录的差异应用到所构建的真正的DOM树上，视图就更新了

2. key的作用原理：
 - 唯一标识，为了高效的更新虚拟DOM
 - transition过渡时，使用key属性，可以区分它们是否变化，否则vue只会替换其内部属性而不会触发过渡效果

> key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速

#### 17、CSRF攻击的原理及解决方案

- csrf攻击原理：
攻击者利用xss方式注入一段脚本，当受害者在浏览器中运行该脚本时，脚本仿冒受害者，向合法的web系统发送一个请求，这个请求会被web系统当做受害者主动提出的合法请求，进而利用合法用户的身份执行攻击者指定的操作。

- csrf攻击解决方法：
目前，防御CSRF攻击主要有三种策略：
1、验证HTTP Referer 字段；
2、在请求地址中添加token并验证；
3、HTTP头中自定义属性并验证。

#### 18、MVVM和MVC的区别

**MVC**
-    **M**：模型层，是应用程序中用于处理应用程序数据逻辑的部分，模型对象负责在数据库中存取数据。
-    **V**：视图层，是应用程序中处理数据显示的部分，视图是依据模型数据创建的
-    **C**(Controller): 控制层，是应用程序中处理用户交互的部分，控制器接受用户的输入并调用模型和视图去完成用户的需求，控制器本身不输出任何东西和做任何处理，它只是接收请求并决定调用那个模型构建去处理请求，然后在确定用哪个视图来显示返回的数据。

**MVVM**
-    **M**：模型层，就是业务逻辑相关的数据对象，通常从数据库映射而来，我们可以说是与数据库对应的model。
-    **V**：视图层。展示出来的用户界面。
-    **VM**： 视图模型层，连接view 和 model 的桥梁。因为 model层中的数据往往是不能直接跟 view 中的控件一一对应上的，所以需要在定义一个数据对象专门对应 view 上的控件，而 viewModel 就是把 model 对象封装成可以显示和接受输入的界面数据对象。

view 和 viewModel 之间通过双向数据绑定建立联系，这样当 view 变化时，会自动更新到 viewModel，反之亦然

**mvvm的优势：**
  1. mvc和 mvvm 都是一种设计思想，主要就是 mvc 中 controller 演变成 mvvm 中的 viewModel。mvvm 主要解决了 mvc 中大量 dom 操作使页面 渲染性能降低，加载速度变慢的问题
  2. mvvm 和 mvc 最大的区别就是：它实现了 view 和 Model 的自动同步，当 model 的属性改变时，我们不用在手动操作 dom 元素来改变 view 的显示，它会自动变化

备注：MVC是**Model-View-Controller**的简写。即模型-视图-控制器。M和V指的意思和MVVM中的M和V意思一样。C即Controller指的是页面业务逻辑。使用MVC的目的就是将M和V的代码分离。MVC是单向通信。也就是View跟Model，必须通过Controller来承上启下。MVC和MVVM的区别并不是VM完全取代了C，只是在MVC的基础上增加了一层VM，只不过是弱化了C的概念，ViewModel存在目的在于抽离Controller中展示的业务逻辑，而不是替代Controller，其它视图操作业务等还是应该放在Controller中实现。也就是说MVVM实现的是业务逻辑组件的重用，使开发更高效，结构更清晰，增加代码的复用性。

#### 19、前端性能优化方法

##### 加载优化
3. 第三方模块使用CDN方式
4. 大模块异步加载，require.ensure
5. 零散的小模块合并一起加载
使用entry指定文件入口，或者头部用import/require建立依赖关系
6. 使用预加载Prefetch，适用于分步场景

##### 图片优化
1. 小图片用Sprite（图片精灵技术）整合成一张图片，减少并发次数，base64内联。
2. 图片懒加载
3. 使用webp格式
4. 压缩图片（`image-minimizer-webpack-plugin`:用来压缩图片的插件）
5. 使用srcset，配置不一样的分辨率对应不同的图片大小，能精准对应不同的尺寸用户

##### css优化
1. css写在头部
假如css写在底部，浏览器会一直等待css全部加载完毕，才能开始解析。
而且下载解析css完毕后，已经呈现的文字和图片需要根据新的样式重绘。
2. 避免css表达式
3. 移除没用的css规则
4. 减少行内样式

##### js优化
1. js放在body底部
这样做无需担心页面未完成加载获取不到dom，也能避免脚本运行缓慢造成页面卡死。
2. js用defer放在头部，不会阻塞dom解析
只对外部脚本文件有效，外部js文件和当前html页面同时加载（异步加载），但只在当前页面解析完成之后执行js代码

##### 渲染优化
1. 减少回流和重绘

#### 20、函数柯里化
```js
// 函数柯里化，利用递归和闭包实现
const curry = function(fn) {
  const len = fn.length; // 获取初始函数fn的形参个数
  
  // curry返回改造后的函数
  return function t() {
    const innerLength = arguments.length; // 获取t的实参个数
    const args = Array.prototype.slice.call(arguments); // 将类数组arguments对象转为真正的数组（类数组arguments对象是函数传入的实际参数，类似数组，拥有数组属性，但不是数组）
      
    if (innerLength >= len) { // 递归出口，如果t实参个数已经大于fn形参个数,则终止递归
      return fn.apply(undefined, args) // 执行改造后的函数

    } else { // 如果t的实参个数少于fn的形参个数，说明柯里化并没有完成，则继续执行柯里化
      return function () {
        const innerArgs = Array.prototype.slice.call(arguments); // 将类数组arguments对象转为真正的数组（类数组arguments对象是函数传入的实际参数，类似数组，拥有数组属性，但不是数组）
        const allArgs = args.concat(innerArgs);
        return t.apply(undefined, allArgs)
      }
    }
  }
}

// 测试
function add (num1, num2, num3, num4, num5) {
  return num1 + num2 + num3 + num4 + num5;
}


const finalFun = curry(add);
const result1 = finalFun(1)(2)(3)(4)(5);
const result2 = finalFun(1, 2)(3)(4)(5);
const result3 = finalFun(1,2,3)(4)(5);
const result4 = finalFun(1,2,3)(4, 5);

console.log(result1, result2, result3, result4); // 15 15 15 15
```

#### 21、AST树
AST树主要是用来做语法抽象的，然后把语法按照树形结构抽象出来，标记出来个各节点，知道节点有什么好处，可以根据自己的需要，比如要对dom节点，或者test节点，或一些方法节点做一些操作时，通过AST，再结合一些线程插件，生成一个.json文件，通过这个文件对整个项目进行分析。
第一可以优化项目，或者做一些loader或者plagin时，可以用到AST。
再者做一些文件的转换、代码的转编译，也可以用到AST。
一些bug的底层或者webpack的底层，都是通过这么一个方式去做的。

#### 22、为什么mutation必须是同步函数，actions 可以处理异步函数
如果我们在mutation中写了异步，commit在触发mutation事件时，异步的回调函数不知道是什么时候执行的，所以在devtools中难以追踪变化。
actions 可以做异步操作，但是并不是直接修改数据，而是通过提交mutations 里面的方法。
这样在devetools就可以追踪到状态的变化。

#### 23、vue中$set的原理
当$set所设置的目标对象为数组时，则调用目标对象的splice方法将修改的数据变为响应式。
当$set所设置的目标对象为对象时，首先判断这个属性是否在这个对象上，如果存在则设置属性为对应的属性值后直接返回val，然后判断目标对象是否为Vue实例或者根数据对象，如果是则warn警告后返回，再去判断这个目标对象是否是响应式的，如果不是响应式对象则直接赋值返回。最后在给目标对象的属性添加响应式，通知dep实例的所有订阅者进行更新。

#### 24、AMD和CMD的区别
**最主要的是：**

AMD是预加载，CMD是懒加载。AMD是提前执行，CMD是延迟执行。
amd (在对应的加载之前导入)，cmd（在用的时候导入）。

**以下为相关补充：**

**AMD**
AMD 即Asynchronous Module Definition，中文名是异步模块定义的意思。
它是一个在浏览器端模块化开发的规范由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎RequireJS，实际上AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出。

requireJS主要解决两个问题：
1、多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器
2、js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长

**CMD**
CMD 即Common Module Definition通用模块定义，CMD规范是国内发展出来的，就像AMD有个requireJS，CMD有个浏览器的实现SeaJS，SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同。
因为CMD推崇一个文件一个模块，所以经常就用文件名作为模块id

CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写。
factory是一个函数，有三个参数，function(require, exports, module)
1.require 是一个方法，接受 模块标识 作为唯一参数，用来获取其他模块提供的接口：require(id)
2.exports 是一个对象，用来向外提供模块接口
3.module 是一个对象，上面存储了与当前模块相关联的一些属性和方法

#### 25、loader
loader主要导出一个函数，它接收三个参数：content、sourceMap、meta，content代表文件处理的信息，基本去用loader处理一些scss、es6，第一个就代表文件信息，这个文件信息也可以通过指定row-loader把它变成原文件的形式。经常使用的是loader中的this，因为this里面存着一些webpack内置的方法，快速的实现一些功能。

#### 26、vue双向数据绑定
底层是通过object.definedPropoty实现的，中间做了一个监听的机制，发布订阅的模式，结合他的一个dep，更新的模式去实现的。
当数据发生改变时，set方法会调用Dep.notify通知所有订阅者Watcher，订阅者就会调用patch给真实的DOM打补丁，更新相应的视图

#### 27、跨域
跨域问题是出于浏览器的安全策略考虑的，跨域它首先有三点：第一点需要在浏览器当中，第二点需要请求后端接口，第三点是触发了同源策略，同源策略是浏览器的一种自我保护机制，它要求三点：域名、协议、端口号，三点一旦触发任何一种不同，都会出现跨域问题。
解决方案：1. 通过后端配置请求头； 2. 本地服务器开启一个代理； 前者在实际项目当中，后者在本地开发当中。

#### 28、纯函数
对于函数式编程，所引申出来的一个概念。他要求函数一个单独的入参同时有一个单独的返回值，对于函数体外部的内容，没有任何影响。函数式编程也是编程的一个常见的编程范式，同时还有面向对象、面向过程。纯函数它的函数是作为一个一等公民，他是第一位的，另外建议你去使用表达式，不使用函数语句，同时纯函数里的内容不可修改，引用的时候清晰透明。好处是容易维护，对外界的影响小。

#### 29、强制缓存和协商缓存
区别：
1. 强制缓存在缓存有效的情况下不会去请求服务器， 其数据来源则是浏览缓存的本地磁盘。而协商缓存会向服务器请求，但是在协商缓存成功的情况下， 服务器只会返回一个不带响应体的报文
2. 强制缓存在浏览器强制刷新的情况下不会生效， 而协商缓存则不受影响。（调试代码测试时候，要注意）
3. 强制缓存返回的报文状态码为 200， 协商缓存返回的报文状态码为 304 （前端使用fetch请求的情况， 协商缓存的 状态码304 会转成 200）
4. 强制缓存发生在浏览器端， 协商缓存发生在服务器端

#### 30、如何给SPA做SEO
下面给出基于Vue的SPA如何实现SEO的三种方式
1. SSR服务端渲染
将组件或页面通过服务器生成html，再返回给浏览器，如nuxt.js
2. 静态化
目前主流的静态化主要有两种：
（1）一种是通过程序将动态页面抓取并保存为静态页面，这样的页面的实际存在于服务器的硬盘中
（2）另外一种是通过WEB服务器的 URL Rewrite的方式，它的原理是通过web服务器内部模块按一定规则将外部的URL请求转化为内部的文件地址，一句话来说就是把外部请求的静态地址转化为实际的动态页面地址，而静态页面实际是不存在的。
这两种方法都达到了实现URL静态化的效果
3. 使用Phantomjs针对爬虫处理
原理是通过Nginx配置，判断访问来源是否为爬虫，如果是则搜索引擎的爬虫请求会转发到一个node server，再通过PhantomJS来解析完整的HTML，返回给爬虫。下面是大致流程图
![](https://static.vue-js.com/25be6630-3ac7-11eb-ab90-d9ae814b240d.png)

#### 31、vue实例挂载的过程
- new Vue的时候调用会调用_init方法
  - 定义 $set、$get 、$delete、$watch 等方法
  - 定义 $emit、$on、$off等事件
  - 定义 _update、$forceUpdate、$destroy生命周期
- 调用$mount进行页面的挂载
- 挂载的时候主要是通过mountComponent方法
- 定义updateComponent更新函数
- 执行render生成虚拟DOM
- _update将虚拟DOM生成真实DOM结构，并且渲染到页面中

#### 32、首屏加载速度慢解决方案
- 减小入口文件体1积
- 静态资源本地缓存
- UI框架按需加载
- 图片资源的压缩
- 组件重复打包
- 开启GZip压缩
- 使用SSR

#### 33、vue中给对象添加新属性界面不刷新
- 如果为对象添加少量的新属性，可以直接采用Vue.set()
- 如果需要为新对象添加大量的新属性，则通过Object.assign()创建新对象
- 如果你实在不知道怎么操作时，可采取$forceUpdate()进行强制刷新 (不建议)

#### 34、Vue.observable
`Vue.observable`，让一个对象变成响应式数据。Vue 内部会用它来处理 data 函数返回的对象

#### 35、vue中的修饰符
1. 表单修饰符
- lazy(在我们填完信息，光标离开标签的时候，才会将值赋予给value，也就是在change事件之后再进行信息同步)
- trim
- number
2. 事件修饰符
- stop
- prevent
- self
- once
- capture(使事件触发从包含这个元素的顶层开始往下触发)
- passive(在移动端，当我们在监听元素滚动事件的时候，会一直触发onscroll事件会让我们的网页变卡，因此我们使用这个修饰符的时候，相当于给onscroll事件整了一个.lazy修饰符)
- native(让组件变成像html内置标签那样监听根元素的原生事件，否则组件上使用 v-on 只会监听自定义事件---使用.native修饰符来操作普通HTML标签是会令事件失效的)
3. 鼠标按钮修饰符
- left 左键点击
- right 右键点击
- middle 中键点击
4. 键盘修饰符
键盘修饰符是用来修饰键盘事件（onkeyup，onkeydown）的
还可以通过以下方式自定义一些全局的键盘码别名`Vue.config.keyCodes.f2 = 113`
5. v-bind修饰符
- sync
- prop(设置自定义标签属性，避免暴露数据，防止污染HTML结构)
- camel(将命名变为驼峰命名法，如将view-Box属性名转换为 viewBox)

#### 36、vue自定义指令
注册一个自定义指令有全局注册与局部注册
全局注册主要是通过Vue.directive方法进行注册
```js
// 注册一个全局自定义指令 `v-focus`
Vue.directive('focus', {
  // 当被绑定的元素插入到 DOM 中时……
  inserted: function (el) {
    // 聚焦元素
    el.focus()  // 页面加载完成之后自动让输入框获取到焦点的小功能
  }
})
```
局部注册通过在组件options选项中设置directive属性
```js
directives: {
  focus: {
    // 指令的定义
    inserted: function (el) {
      el.focus() // 页面加载完成之后自动让输入框获取到焦点的小功能
    }
  }
}
```
**自定义指令也像组件那样存在钩子函数：**
- bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置
- inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)
- update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新
- componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用
- unbind：只调用一次，指令与元素解绑时调用

**所有的钩子函数的参数都有以下：**
- el：指令所绑定的元素，可以用来直接操作 DOM
- binding：一个对象，包含以下 property：
  - name：指令名，不包括 v- 前缀。
  - value：指令的绑定值，例如：v-my-directive="1 + 1" 中，绑定值为 2。
  - oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。
  - expression：字符串形式的指令表达式。例如 v-my-directive="1 + 1" 中，表达式为 "1 + 1"。
  - arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 "foo"。
  - modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }
- vnode：Vue 编译生成的虚拟节点
- oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用

#### 37、vue3相对于vue2做的优化
1. 编译阶段
- diff算法优化
vue3在diff算法中相比vue2增加了静态标记
关于这个静态标记，其作用是为了会发生变化的地方添加一个flag标记，下次发生变化的时候直接找该地方进行比较
- 静态提升
Vue3中对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用
这样就免去了重复的创建节点，大型应用会受益于这个改动，免去了重复的创建操作，优化了运行时候的内存占用
- 事件监听缓存
默认情况下绑定事件行为会被视为动态绑定，所以每次都会去追踪它的变化
开启了缓存后，没有了静态标记。也就是说下次diff算法的时候直接使用
- SSR优化
当静态内容大到一定量级时候，会用createStaticVNode方法在客户端去生成一个static node，这些静态node，会被直接innerHtml，就不需要创建对象，然后根据对象渲染

2. 源码体积
相比Vue2，Vue3整体体积变小了，除了移出一些不常用的API，再重要的是Tree shanking
任何一个函数，如ref、reavtived、computed等，仅仅在用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小

3. 响应式系统
vue2中采用 defineProperty来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加getter和setter，实现响应式
vue3采用proxy重写了响应式系统，因为proxy可以对整个对象进行监听，所以不需要深度遍历
- 可以监听动态属性的添加
- 可以监听到数组的索引和数组length属性
- 可以监听删除属性

#### 38、Typescript数据类型

- boolean（布尔类型）
- number（数字类型）
- string（字符串类型）
- array（数组类型）
- tuple（元组类型）
- enum（枚举类型）
- any（任意类型）
- null 和 undefined 类型
- void 类型
- never 类型
- object 对象类型

#### 39、this指向

- 全局函数：普通模式，普通函数中的this指向顶级对象window<br>严格模式，普通函数中的this指向undefined
- 在对象的方法中，this指向的是该对象
- 在构造函数中，this指向构造函数的实例
- 在事件中，this指向事件源

#### 40、call、apply、bind

- call
call方法的第一个参数也是this的指向，后面传入的是一个参数列表
跟apply一样，改变this指向后原函数会立即执行，且此方法只是临时改变this指向一次
- apply
apply接受两个参数，第一个参数是this的指向，第二个参数是函数接受的参数，以数组的形式传入
改变this指向后原函数会立即执行，且此方法只是临时改变this指向一次
- bind
bind方法和call很相似，第一参数也是this的指向，后面传入的也是一个参数列表(但是这个参数列表可以分多次传入)
改变this指向后不会立即执行，而是返回一个永久改变this指向的函数

**小结**

- 三者都可以改变函数的`this`对象指向
- 三者第一个参数都是`this`要指向的对象，如果如果没有这个参数或参数为`undefined`或`null`，则默认指向全局`window`
- 三者都可以传参，但是`apply`是数组，而`call`是参数列表，且`apply`和`call`是一次性传入参数，而`bind`可以分为多次传入
- `bind`是返回绑定this之后的函数，`apply`、`call` 则是立即执行

#### 41、react生命周期函数

- 创建阶段
  - constructor
  - getDerivedStateFromProps
  - render
  - componentDidMount
- 更新阶段
  - getDerivedStateFromProps
  - shouldComponentUpdate
  - render
  - getSnapshotBeforeUpdate
  - componentDidMount

#### 42、nextick使用场景和原理
使用场景：如果想要在修改数据后立刻得到更新后的DOM结构，可以使用Vue.nextTick()

原理：
1. 把回调函数放入callbacks等待执行
2. 将执行函数放到微任务或者宏任务中
3. 事件循环到了微任务或者宏任务，执行函数依次执行callbacks中的回调

#### 43、组件给name属性的优点
增加 name 属性，可以实现组件递归调⽤自身，调用的时候用的就是 name 名字 可以表示组件的具体名称，⽅便调试和查找对应的组件 比如说 keep-alive 的 include 和 exclude 就是通过组件的 name 属性区分谁缓存谁不缓存的

#### 44、keep-alive实现原理
> 具体实现上，keep-alive在内部维护了一个key数组和一个缓存对象

> key数组记录目前缓存的组件key值，如果组件没有指定key值，会自动生成一个唯一的key值
cache对象会以key值为键，vnode为值，用于缓存组件对应的虚拟DOM
在keep-alive的渲染函数中，其基本逻辑是判断当前渲染的vnode是否有对应的缓存，如果有，会从缓存中读取到对应的组件实例，如果没有就会把它缓存。
当缓存的数量超过max设置的数值时，keep-alive会移除key数组中的第一个元素